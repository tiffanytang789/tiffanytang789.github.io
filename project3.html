<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Project Title</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --maxw: 1100px; }
    * { box-sizing: border-box; }
    body {
      margin: 0 auto; padding: 2rem 1rem; max-width: var(--maxw);
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: #111; background: #fff;
    }
    header h1 { margin: 0 0 1.25rem; font-size: 2rem; line-height: 1.25; }
    h2, h3, h4 { margin: 2.25rem 0 1rem; line-height: 1.25; }
    p { margin: 0.75rem 0 1rem; }
    .image-row {
      display: grid; gap: 12px; margin: 0.5rem 0 0.35rem;
    }
    .cols-2 { grid-template-columns: repeat(2, 1fr); }
    .cols-3 { grid-template-columns: repeat(3, 1fr); }
    figure { margin: 0; }
    img {
      display: block; width: 100%; height: auto;
      border-radius: 8px; border: 1px solid #e6e6e6;
    }
    figcaption, .row-caption {
      font-size: 0.95rem; color: #555; margin: 0.35rem 0 1rem;
    }
    /* Optional: make tall images consistent height without cropping content too hard */
    .fit-cover img { aspect-ratio: 3/2; object-fit: cover; }
    .fit-contain img { background: #fafafa; object-fit: contain; }
    /* Keep things readable on small screens */
    @media (max-width: 640px) {
      .cols-2, .cols-3 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

  <!-- Visible Title -->
  <header>
    <h1>Project 3 - IMAGE WARPING and MOSAICING</h1>
  </header>

  <!-- Heading 1 -->
  <h2>A.1</h2>

  <!-- 2 images in a row, caption -->
  <div class="image-row cols-2 fit-cover">
    <figure><img src="IMG_8301.jpg" alt="Describe image 1" /></figure>
    <figure><img src="IMG_8303.jpg" alt="Describe image 2" /></figure>
  </div>
  <div class="row-caption">image of study space </div>

  <!-- 2 images in a row, caption -->
  <div class="image-row cols-2 fit-cover">
    <figure><img src="IMG_8308.jpg" alt="Describe image 3" /></figure>
    <figure><img src="IMG_8309.jpg" alt="Describe image 4" /></figure>
  </div>
  <div class="row-caption">image of kitchen.</div>

  <!-- 2 images in a row, caption -->
  <div class="image-row cols-2 fit-cover">
    <figure><img src="IMG_8311.jpg" alt="Describe image 5" /></figure>
    <figure><img src="IMG_8310.jpg" alt="Describe image 6" /></figure>
  </div>
  <div class="row-caption">images of living room.</div>
 
    

  <!-- Heading 2 -->
  <h2>A.2</h2>

  <!-- 2 images in a row, caption -->
  <figure><img src="points_space.png" alt="Describe image 7" /></figure>
  <div class="row-caption">Caption (H2 Row 1).</div>

  <!-- 2 images in a row, caption -->
  <figure><img src="points_kitchen.png" alt="Describe image 9" /></figure>
  <div class="row-caption">Caption (H2 Row 2).</div>

  <!-- 2 images in a row, caption -->
  <figure><img src="points_living.png" alt="Describe image 11" /></figure>
  <div class="row-caption">Caption (H2 Row 3).</div>

  <p>
    <ol>
      <li>Solve the linear least squares problem A h ≈ b using a robust solver (e.g., QR or SVD).</li>
      <li>Form the 3×3 matrix:
        <br><br>
        H = [[h<sub>11</sub>, h<sub>12</sub>, h<sub>13</sub>],
        [h<sub>21</sub>, h<sub>22</sub>, h<sub>23</sub>],
        [h<sub>31</sub>, h<sub>32</sub>, 1]]
      </li>
      <li>Scale H so that ‖H‖ has a convenient magnitude (e.g., set H<sub>33</sub> = 1).</li>
      <li>Optionally use the homogeneous 9-parameter DLT with SVD by stacking rows
        [−x, −y, −1, 0, 0, 0, x x′, y x′, x′] and
        [0, 0, 0, −x, −y, −1, x y′, y y′, y′], then take the right singular vector with the smallest singular value and reshape to H.</li>
    </ol>
  </p>

  <!-- Heading 3 -->
  <h3>A.3</h3>

  <!-- 3 images in a row, caption -->
  <div class="image-row cols-3 fit-cover">
    <figure><img src="IMG_8308.jpg" alt="Describe image 13" /></figure>
    <figure><img src="8308nnwarp.png" alt="Describe image 14" /></figure>
    <figure><img src="8308_warp.png" alt="Describe image 15" /></figure>
  </div>
  <div class="row-caption">Original, NN, Bilinear.\n Warp (NN) took 1.840 s  (1840.3 ms)
Warp (Bilinear) took 4.307 s  (4307.2 ms)</div>

  <!-- 3 images in a row, caption -->
  <div class="image-row cols-3 fit-cover">
    <figure><img src="IMG_8311.jpg" alt="Describe image 16" /></figure>
    <figure><img src="8311nnwarp.png" alt="Describe image 17" /></figure>
    <figure><img src="8311warp.png" alt="Describe image 18" /></figure>
  </div>
  <div class="row-caption">Original, NN, Bilinear.\n Warp (NN) took 3.125 s  (3124.7 ms)
Warp (Bilinear) took 6.625 s  (6625.3 ms).</div>

  <!-- 3 images in a row, caption -->
  <div class="image-row cols-3 fit-cover">
    <figure><img src="IMG_8303.jpg" alt="Describe image 19" /></figure>
    <figure><img src="warped_8303.png" alt="Describe image 20" /></figure>
    <figure><img src="warped_8303_bilinear.png" alt="Describe image 21" /></figure>
  </div>
  <div class="row-caption">Original, NN, Bilinear.\n Warp (NN) took 0.328 s  (328.2 ms)
Warp (Bilinear) took 0.699 s  (698.5 ms)</div>

  <p>
    <ol>
      <li>Compute output canvas bounds by projecting the four corners of the source image through H and taking min/max of the projected coordinates together with the reference image corners.</li>
      <li>Use inverse mapping for each output pixel (u, v): compute [x, y, w]<sup>T</sup> = H<sup>−1</sup>[u, v, 1]<sup>T</sup>, then x̃ = x/w, ỹ = y/w.</li>
      <li>Sample the source image at (x̃, ỹ) using bilinear interpolation for smoother results (nearest neighbor is acceptable for speed).</li>
      <li>Composite the warped image onto the reference:
        <ul>
          <li>Simple overwrite in non-overlap regions.</li>
          <li>In overlap, use feathering with weights that decay from each image’s boundary, or use a linear alpha ramp.</li>
        </ul>
      </li>
      <li>Return the stitched mosaic and the warp grid if needed for debugging.</li>
    </ol>
    NN is faster but Bilinear produces better quality 
  </p>

  <!-- Heading 4 -->
  <h4>A.4</h4>

  <!-- Group 1: 2 images in a row, caption; then 1 image, caption -->
  <div class="image-row cols-2 fit-cover">
    <figure><img src="IMG_8303.jpg" alt="Describe image 22" /></figure>
    <figure><img src="IMG_8301.jpg" alt="Describe image 23" /></figure>
  </div>
  <div class="row-caption">Caption (H4 Group 1 — two images).</div>

  <figure>
    <img src="mosaic_space.png" alt="Describe image 24" />
    <figcaption>Caption (H4 Group 1 — single image).</figcaption>
  </figure>

  <!-- Group 2: 2 images in a row, caption; then 1 image, caption -->
  <div class="image-row cols-2 fit-cover">
    <figure><img src="IMG_8308.jpg" alt="Describe image 25" /></figure>
    <figure><img src="IMG_8309.jpg" alt="Describe image 26" /></figure>
  </div>
  <div class="row-caption">Caption (H4 Group 2 — two images).</div>

  <figure>
    <img src="mosaic_kitchen.png" alt="Describe image 27" />
    <figcaption>Caption (H4 Group 2 — single image).</figcaption>
  </figure>

  <!-- Group 3: 2 images in a row, caption; then 1 image, caption -->
  <div class="image-row cols-2 fit-cover">
    <figure><img src="IMG_8311.jpg" alt="Describe image 28" /></figure>
    <figure><img src="IMG_8310.jpg" alt="Describe image 29" /></figure>
  </div>
  <div class="row-caption">Caption (H4 Group 3 — two images).</div>

  <figure>
    <img src="livingroom_mosaic.png" alt="Describe image 30" />
    <figcaption>Caption (H4 Group 3 — single image).</figcaption>
  </figure>

  <p>
    <ol>
      <li>Plot correspondences by drawing the two images side by side, offsetting the second image’s x-coordinates, and connecting matched points with line segments.</li>
      <li>Overlay the point locations on their respective images by drawing small circles at (x, y) and (x′, y′) with index labels.</li>
      <li>Visualize the warp by projecting a regular grid from the source image through H and drawing the transformed grid on the mosaic.</li>
      <li>Measure runtime for a function call such as imwarp = warpImageNearestNeighbor(im, H) using a high-resolution timer:
        <br><br>
        t<sub>0</sub> = now, run the function, t<sub>1</sub> = now, Δt = t<sub>1</sub> − t<sub>0</sub>.
      </li>
      <li>Report pixel count, interpolation mode, and elapsed time to compare performance across settings.</li>
    </ol>
  </p>

    <!-- ===================== -->
  <!-- Part B                -->
  <!-- ===================== -->

  <h2>Part B.1</h2>
  <!-- 3 images in a row, each with its own caption, then a paragraph -->
  <div class="image-row cols-3 fit-cover">
    <figure>
      <img src="IMG_6311.jpg" alt="B1 image 1">
      <figcaption>Original image</figcaption>
    </figure>
    <figure>
      <img src="6311_all.png" alt="B1 image 2">
      <figcaption>without ANMS</figcaption>
    </figure>
    <figure>
      <img src="6311_anms.png" alt="B1 image 3">
      <figcaption>with ANMS</figcaption>
    </figure>
  </div>
  <p>
     <ol>
      <li>
        Compute corner strength f(x<sub>i</sub>) (e.g., Harris response) for each interest point.
      </li>
      <li>
        For every point x<sub>i</sub>, find its suppression radius r<sub>i</sub>:
        <br><br>
        r<sub>i</sub> = min<sub>j</sub> ||x<sub>i</sub> − x<sub>j</sub>|| 
        &nbsp;&nbsp; s.t.&nbsp; f(x<sub>i</sub>) &lt; c<sub>robust</sub> · f(x<sub>j</sub>)
        <ul>
          <li>
            Here, x<sub>j</sub> are stronger neighbors, and c<sub>robust</sub> ≈ 0.9 ensures the neighbor must be significantly stronger.
          </li>
        </ul>
      </li>
      <li>
        The radius r<sub>i</sub> measures how far you must go from x<sub>i</sub> to find a clearly stronger corner.
        <ul>
          <li>Strong isolated points → large r<sub>i</sub></li>
          <li>Weak clustered points → small r<sub>i</sub></li>
        </ul>
      </li>
      <li>
        Select the top N points with the largest radii — these are spatially diverse yet strong corners.
      </li>
    </ol>
  </p>

  <h2>Part B.2</h2>
  <!-- 1 image, caption, then a paragraph -->
  <figure>
    <img src="descriptors_grid.png" alt="B2 image">
    <figcaption>20 descriptors</figcaption>
  </figure>
  <p>
    <ol>
      <li>For each retained corner x<sub>i</sub>, extract a square grayscale patch centered at x<sub>i</sub> (e.g., 40×40 pixels) using interpolation to handle subpixel locations.</li>
      <li>Downsample or blur the patch to reduce noise and small misalignments (e.g., blur then resize to 8×8 or 16×16).</li>
      <li>Vectorize the patch to get p<sub>i</sub>. Normalize to achieve invariance to contrast:
        <br><br>
        p̄<sub>i</sub> = (p<sub>i</sub> − μ<sub>i</sub>) / (σ<sub>i</sub> + ε)
        <br><br>
        where μ<sub>i</sub> is the mean intensity of the patch, σ<sub>i</sub> its standard deviation, and ε is a small constant.
      </li>
      <li>Optionally clamp the values to a fixed range to reduce outliers (e.g., clip to [−3, 3]), then renormalize to unit length. The resulting descriptor is d<sub>i</sub>.</li>
      <li>Store (x<sub>i</sub>, d<sub>i</sub>) for matching.</li>
    </ol>

  </p>

  <h2>Part B.3</h2>
  <!-- 1 image, caption, then a paragraph -->
  <figure>
    <img src="matches_ratio08.png" alt="B3 image">
    <figcaption>matched features</figcaption>
  </figure>
  <p>
    <ol>
      <li>Given descriptors d<sub>i</sub> from image A and d′<sub>j</sub> from image B, compute pairwise distances using SSD:
        <br><br>
        SSD(i, j) = ‖d<sub>i</sub> − d′<sub>j</sub>‖<sup>2</sup>
      </li>
      <li>For each d<sub>i</sub>, find its two nearest neighbors in B with distances s<sub>1</sub> ≤ s<sub>2</sub>.</li>
      <li>Apply the ratio test to reject ambiguous matches:
        <br><br>
        s<sub>1</sub> / s<sub>2</sub> &lt; τ
        <br><br>
        where τ is typically 0.7–0.8. Pairs failing the test are discarded.
      </li>
      <li>Optionally enforce mutual consistency: keep (i, j) only if i is the best match for j and j is the best for i.</li>
      <li>The surviving pairs (x<sub>i</sub> ↔ x′<sub>j</sub>) are candidate correspondences.</li>
    </ol>
  </p>

  <h2>Part B.4</h2>
  <!-- 3 rows of 2 images side by side -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="mosaic_kitchen.png" alt="B4 row 1 col 1"><figcaption>Part A</figcaption></figure>
    <figure><img src="mosaic_auto_kitchen.png" alt="B4 row 1 col 2"><figcaption>Auto Mosaic</figcaption></figure>
  </div>
  <div class="image-row cols-2 fit-contain">
    <figure><img src="livingroom_mosaic.png" alt="B4 row 2 col 1"><figcaption>Part A</figcaption></figure>
    <figure><img src="mosaic_auto_living_v1.png" alt="B4 row 2 col 2"><figcaption>Auto Mosaic</figcaption></figure>
  </div>
  <div class="image-row cols-2 fit-contain">
    <figure><img src="mosaic_space.png" alt="B4 row 3 col 1"><figcaption>Part A</figcaption></figure>
    <figure><img src="mosaic_auto_space.png" alt="B4 row 3 col 2"><figcaption>Auto Mosaic</figcaption></figure>
  </div>

  <!-- 2 rows of 3 images side by side -->
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_2180.jpg" alt="B4 row 4 col 1"></figure>
    <figure><img src="IMG_2181.jpg" alt="B4 row 4 col 2"></figure>
    <figure><img src="mosaic_auto_view.png" alt="B4 row 4 col 3"></figure>
  </div>
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_1071.jpg" alt="B4 row 5 col 1"></figure>
    <figure><img src="IMG_1072.jpg" alt="B4 row 5 col 2"></figure>
    <figure><img src="mosaic_auto_shanghai.png" alt="B4 row 5 col 3"></figure>
  </div>
  </div>
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_0415.jpg" alt="B4 row 5 col 1"></figure>
    <figure><img src="IMG_0416.jpg" alt="B4 row 5 col 2"></figure>
    <figure><img src="mosaic_auto_palace.png" alt="B4 row 5 col 3"></figure>
  </div>

  <p>
    <ol>
      <li>Input the candidate correspondences (x<sub>i</sub> ↔ x′<sub>j</sub>). Define an inlier threshold ε in pixels for reprojection error.</li>
      <li>Repeat for N iterations:
        <ul>
          <li>Randomly sample 4 correspondences and estimate a homography H using the DLT formulation.</li>
          <li>Project points from A to B: x̂′ = H x (homogeneous coordinates), then normalize.</li>
          <li>Compute reprojection error e = ‖x̂′ − x′‖. Mark a correspondence as an inlier if e &lt; ε.</li>
        </ul>
      </li>
      <li>Keep the hypothesis H with the largest inlier set. Refit H using all inliers via least squares for the final estimate.</li>
      <li>Return H and the inlier correspondences for downstream warping and blending.</li>
    </ol>
  </p>


</body>
</html>
