<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Project Title</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --maxw: 1100px; }
    * { box-sizing: border-box; }
    body {
      margin: 0 auto; padding: 2rem 1rem; max-width: var(--maxw);
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: #111; background: #fff;
    }
    header h1 { margin: 0 0 1.25rem; font-size: 2rem; line-height: 1.25; }
    h2, h3, h4 { margin: 2.25rem 0 1rem; line-height: 1.25; }
    p { margin: 0.75rem 0 1rem; }
    .image-row {
      display: grid; gap: 12px; margin: 0.5rem 0 0.35rem;
    }
    .cols-2 { grid-template-columns: repeat(2, 1fr); }
    .cols-3 { grid-template-columns: repeat(3, 1fr); }
    figure { margin: 0; }
    img {
      display: block; width: 100%; height: auto;
      border-radius: 8px; border: 1px solid #e6e6e6;
    }
    figcaption, .row-caption {
      font-size: 0.95rem; color: #555; margin: 0.35rem 0 1rem;
    }
    /* Optional: make tall images consistent height without cropping content too hard */
    .fit-cover img { aspect-ratio: 3/2; object-fit: cover; }
    .fit-contain img { background: #fafafa; object-fit: contain; }
    /* Keep things readable on small screens */
    @media (max-width: 640px) {
      .cols-2, .cols-3 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

  <!-- Visible Title -->
  <header>
    <h1>Project 3 - [Auto]Stitching Photo Mosaics</h1>
  </header>

  <!-- Heading 1 -->
  <h2>A.1: Shoot and digitize pictures</h2>

  <!-- 2 images in a row, caption -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="IMG_8301.jpg" alt="Describe image 1" /></figure>
    <figure><img src="IMG_8303.jpg" alt="Describe image 2" /></figure>
  </div>
  <div class="row-caption">image of study space </div>

  <!-- 2 images in a row, caption -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="IMG_8308.jpg" alt="Describe image 3" /></figure>
    <figure><img src="IMG_8309.jpg" alt="Describe image 4" /></figure>
  </div>
  <div class="row-caption">image of kitchen.</div>

  <!-- 2 images in a row, caption -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="IMG_8311.jpg" alt="Describe image 5" /></figure>
    <figure><img src="IMG_8310.jpg" alt="Describe image 6" /></figure>
  </div>
  <div class="row-caption">images of living room.</div>
 
    

  <!-- Heading 2 -->
  <h2>A.2: Recover homographies </h2>

  <!-- 2 images in a row, caption -->
  <figure><img src="points_space.png" alt="Describe image 7" /></figure>

  <!-- 2 images in a row, caption -->
  <figure><img src="points_kitchen.png" alt="Describe image 9" /></figure>

  <!-- 2 images in a row, caption -->
  <figure><img src="points_living.png" alt="Describe image 11" /></figure>

  <p>
    <ol>
      <li>Collect at least four pairs of matching points (x, y) ↔ (x′, y′) between the two images.</li>
      <li>For each pair, create two rows in matrix A that represent the homography constraints.  
        The unknowns are the eight parameters of H (h<sub>11</sub> … h<sub>32</sub>, with h<sub>33</sub> = 1).
      </li>
      <li>Stack all correspondences to form the full linear system A h ≈ b.</li>
      <li>Solve for h using least squares or SVD.  
        Reshape the result into the 3×3 homography matrix:
        <br><br>
        H = [[h<sub>11</sub>, h<sub>12</sub>, h<sub>13</sub>],
        [h<sub>21</sub>, h<sub>22</sub>, h<sub>23</sub>],
        [h<sub>31</sub>, h<sub>32</sub>, 1]]
      </li>
      <li>Normalize H so that the scale is consistent (commonly set h<sub>33</sub> = 1).</li>
    </ol>
  </p>

  <!-- Heading 3 -->
  <h3>A.3: Warp the images </h3>

  <!-- 3 images in a row, caption -->
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_8308.jpg" alt="Describe image 13" /></figure>
    <figure><img src="8308nnwarp.png" alt="Describe image 14" /></figure>
    <figure><img src="8308_warp.png" alt="Describe image 15" /></figure>
  </div>
  <div class="row-caption">Original, NN, Bilinear.\n Warp (NN) took 1.840 s  (1840.3 ms)
Warp (Bilinear) took 4.307 s  (4307.2 ms)</div>

  <!-- 3 images in a row, caption -->
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_8311.jpg" alt="Describe image 16" /></figure>
    <figure><img src="8311nnwarp.png" alt="Describe image 17" /></figure>
    <figure><img src="8311warp.png" alt="Describe image 18" /></figure>
  </div>
  <div class="row-caption">Original, NN, Bilinear.\n Warp (NN) took 3.125 s  (3124.7 ms)
Warp (Bilinear) took 6.625 s  (6625.3 ms).</div>

  <!-- 3 images in a row, caption -->
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_8303.jpg" alt="Describe image 19" /></figure>
    <figure><img src="warped_8303.png" alt="Describe image 20" /></figure>
    <figure><img src="warped_8303_bilinear.png" alt="Describe image 21" /></figure>
  </div>
  <div class="row-caption">Original, NN, Bilinear.\n Warp (NN) took 0.328 s  (328.2 ms)
Warp (Bilinear) took 0.699 s  (698.5 ms)</div>

  <p>
     <ol>
      <li>Project the corners of the source image through H to estimate the overall canvas bounds.</li>
      <li>For each output pixel (u, v), compute the corresponding source coordinate using inverse mapping:
        <br><br>
        [x, y, w]<sup>T</sup> = H<sup>−1</sup>[u, v, 1]<sup>T</sup>, then x̃ = x/w, ỹ = y/w.
      </li>
      <li>Sample the source pixel at (x̃, ỹ) using bilinear interpolation for smoother results  
        (nearest neighbor can be used for speed).</li>
      <li>Overlay the warped image onto the reference:
        <ul>
          <li>Use simple overwrite where there’s no overlap.</li>
          <li>In overlapping regions, apply feathering or alpha blending to smooth seams.</li>
        </ul>
      </li>
      <li>The result is the stitched mosaic image</li>
    </ol>
    NN is faster but Bilinear produces better quality 
  </p>

  <!-- Heading 4 -->
  <h4>A.4: Blend images into a mosaic </h4>

  <!-- Group 1: 2 images in a row, caption; then 1 image, caption -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="IMG_8303.jpg" alt="Describe image 22" /></figure>
    <figure><img src="IMG_8301.jpg" alt="Describe image 23" /></figure>
  </div>

  <figure>
    <img src="mosaic_space.png" alt="Describe image 24" />
  </figure>

  <!-- Group 2: 2 images in a row, caption; then 1 image, caption -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="IMG_8308.jpg" alt="Describe image 25" /></figure>
    <figure><img src="IMG_8309.jpg" alt="Describe image 26" /></figure>
  </div>

  <figure>
    <img src="mosaic_kitchen.png" alt="Describe image 27" />
  </figure>

  <!-- Group 3: 2 images in a row, caption; then 1 image, caption -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="IMG_8311.jpg" alt="Describe image 28" /></figure>
    <figure><img src="IMG_8310.jpg" alt="Describe image 29" /></figure>
  </div>

  <figure>
    <img src="livingroom_mosaic.png" alt="Describe image 30" />
  </figure>

  <p>
      <ol>
      <li>Visualize correspondences by plotting both images side by side and connecting matched points with lines.</li>
      <li>Draw detected feature locations as small circles on each image to check accuracy.</li>
      <li>Project a regular grid through H and display it on the mosaic to visualize distortion.</li>
      <li>Measure runtime for the warp function using timestamps:
        <br><br>
        t₀ = start time, t₁ = end time, Δt = t₁ − t₀
      </li>
      <li>Record the runtime, number of pixels processed, and interpolation method to compare performance.</li>
    </ol>
  </p>

    <!-- ===================== -->
  <!-- Part B                -->
  <!-- ===================== -->

  <h2>Part B.1: Harris Corner Detection</h2>
  <!-- 3 images in a row, each with its own caption, then a paragraph -->
  <div class="image-row cols-3 fit-contain">
    <figure>
      <img src="IMG_6311.jpg" alt="B1 image 1">
      <figcaption>Original image</figcaption>
    </figure>
    <figure>
      <img src="6311_all.png" alt="B1 image 2">
      <figcaption>without ANMS</figcaption>
    </figure>
    <figure>
      <img src="6311_anms.png" alt="B1 image 3">
      <figcaption>with ANMS</figcaption>
    </figure>
  </div>
  <p>
     <ol>
      <li>
        Compute corner strength f(x<sub>i</sub>) (e.g., Harris response) for each interest point.
      </li>
      <li>
        For every point x<sub>i</sub>, find its suppression radius r<sub>i</sub>:
        <br><br>
        r<sub>i</sub> = min<sub>j</sub> ||x<sub>i</sub> − x<sub>j</sub>|| 
        &nbsp;&nbsp; s.t.&nbsp; f(x<sub>i</sub>) &lt; c<sub>robust</sub> · f(x<sub>j</sub>)
        <ul>
          <li>
            Here, x<sub>j</sub> are stronger neighbors, and c<sub>robust</sub> ≈ 0.9 ensures the neighbor must be significantly stronger.
          </li>
        </ul>
      </li>
      <li>
        The radius r<sub>i</sub> measures how far you must go from x<sub>i</sub> to find a clearly stronger corner.
        <ul>
          <li>Strong isolated points → large r<sub>i</sub></li>
          <li>Weak clustered points → small r<sub>i</sub></li>
        </ul>
      </li>
      <li>
        Select the top N points with the largest radii — these are spatially diverse yet strong corners.
      </li>
    </ol>
  </p>

  <h2>Part B.2: Feature Descriptor Extraction</h2>
  <!-- 1 image, caption, then a paragraph -->
  <figure>
    <img src="descriptors_grid.png" alt="B2 image">
    <figcaption>20 descriptors</figcaption>
  </figure>
  <p>
    <ol>
      <li>For each corner x<sub>i</sub>, take a small grayscale patch centered at that point (around 40×40 px) and use interpolation if needed to handle subpixel locations.</li>
      <li>Apply a light blur or resize the patch down (for example, to 8×8 or 16×16) so small alignment differences don’t matter as much.</li>
      <li>Flatten the patch into a vector p<sub>i</sub> and normalize it:
        <br><br>
        p̄<sub>i</sub> = (p<sub>i</sub> − μ<sub>i</sub>) / (σ<sub>i</sub> + ε)
        <br><br>
        where μ<sub>i</sub> is the patch mean, σ<sub>i</sub> its standard deviation, and ε is a small constant for stability.
      </li>
      <li>Clamp the vector to a fixed range (like [−3, 3]) and re-normalize to unit length. This gives the final descriptor d<sub>i</sub>.</li>
      <li>Store each (x<sub>i</sub>, d<sub>i</sub>) pair to use later for matching.</li>
    </ol>

  </p>

  <h2>Part B.3: Feature Matching</h2>
  <!-- 1 image, caption, then a paragraph -->
  <figure>
    <img src="matches_ratio08.png" alt="B3 image">
    <figcaption>matched features</figcaption>
  </figure>
  <p>
    <ol>
      <li>Take all descriptors from image A and B. Compute the squared distance (SSD) between every pair:
        <br><br>
        SSD(i, j) = ‖d<sub>i</sub> − d′<sub>j</sub>‖²
      </li>
      <li>For each d<sub>i</sub>, find its two nearest neighbors in B. Let their distances be s<sub>1</sub> and s<sub>2</sub>.</li>
      <li>Use the ratio test s<sub>1</sub>/s<sub>2</sub> &lt; τ (typically 0.7 – 0.8) to remove ambiguous matches.</li>
      <li>The remaining pairs (x<sub>i</sub> ↔ x′<sub>j</sub>) are your reliable matches.</li>
    </ol>
  </p>

  <h2>Part B.4: RANSAC for Robust Homography</h2>
  <!-- 3 rows of 2 images side by side -->
  <div class="image-row cols-2 fit-contain">
    <figure><img src="mosaic_kitchen.png" alt="B4 row 1 col 1"><figcaption>Part A</figcaption></figure>
    <figure><img src="mosaic_auto_kitchen.png" alt="B4 row 1 col 2"><figcaption>Auto Mosaic</figcaption></figure>
  </div>
  <div class="image-row cols-2 fit-contain">
    <figure><img src="livingroom_mosaic.png" alt="B4 row 2 col 1"><figcaption>Part A</figcaption></figure>
    <figure><img src="mosaic_auto_living_v1.png" alt="B4 row 2 col 2"><figcaption>Auto Mosaic</figcaption></figure>
  </div>
  <div class="image-row cols-2 fit-contain">
    <figure><img src="mosaic_space.png" alt="B4 row 3 col 1"><figcaption>Part A</figcaption></figure>
    <figure><img src="mosaic_auto_space.png" alt="B4 row 3 col 2"><figcaption>Auto Mosaic</figcaption></figure>
  </div>

  <!-- 2 rows of 3 images side by side -->
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_2180.jpg" alt="B4 row 4 col 1"></figure>
    <figure><img src="IMG_2181.jpg" alt="B4 row 4 col 2"></figure>
    <figure><img src="mosaic_auto_view.png" alt="B4 row 4 col 3"></figure>
  </div>
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_1071.jpg" alt="B4 row 5 col 1"></figure>
    <figure><img src="IMG_1072.jpg" alt="B4 row 5 col 2"></figure>
    <figure><img src="mosaic_auto_shanghai.png" alt="B4 row 5 col 3"></figure>
  </div>
  </div>
  <div class="image-row cols-3 fit-contain">
    <figure><img src="IMG_0415.jpg" alt="B4 row 5 col 1"></figure>
    <figure><img src="IMG_0416.jpg" alt="B4 row 5 col 2"></figure>
    <figure><img src="mosaic_auto_palace.png" alt="B4 row 5 col 3"></figure>
  </div>

  <p>
    <ol>
      <li>Start with all candidate matches (x<sub>i</sub> ↔ x′<sub>j</sub>) and pick an inlier threshold ε for reprojection error (in pixels).</li>
      <li>Run RANSAC for N iterations:
        <ul>
          <li>Randomly choose 4 matches and estimate H with DLT.</li>
          <li>Warp points from A → B using H and normalize.</li>
          <li>Compute reprojection error e = ‖x̂′ − x′‖ and mark inliers if e &lt; ε.</li>
        </ul>
      </li>
      <li>Keep the H with the most inliers, then recompute H using all of them for a refined fit.</li>
      <li>Return the final H and inlier set — these define the robust alignment used for the automatic mosaics.</li>
    </ol>
  </p>


</body>
</html>
